{
  "scan_metadata": {
    "scan_date": "2025-11-19",
    "target": "/home/user/aupat",
    "total_files_scanned": 75,
    "python_files_analyzed": 45,
    "scan_categories": ["sql_injection", "path_traversal", "race_conditions", "memory_issues", "error_handling", "resource_leaks", "type_errors", "logic_errors", "security", "performance"]
  },
  "bugs": [
    {
      "id": "BUG-001",
      "file": "/home/user/aupat/scripts/db_migrate_add_stats_columns.py",
      "line": 56,
      "category": "SQL_INJECTION",
      "severity": "HIGH",
      "title": "SQL Injection via f-string in ALTER TABLE",
      "description": "Column name directly interpolated in f-string without parameterization. While col_name is from internal list, using f-strings for identifiers is anti-pattern.",
      "code_snippet": "cursor.execute(f\"ALTER TABLE locations ADD COLUMN {col_name} {col_def}\")",
      "impact": "If col_name or col_def becomes user-controlled in future, direct SQL injection vulnerability",
      "scenario": "Attacker could inject malicious SQL through col_name parameter if it ever accepts user input",
      "recommendation": "Use identifier quoting or safer patterns for schema operations"
    },
    {
      "id": "BUG-002",
      "file": "/home/user/aupat/scripts/fix_schema.py",
      "line": 33,
      "category": "SQL_INJECTION",
      "severity": "HIGH",
      "title": "SQL Injection via f-string in ALTER TABLE",
      "description": "Column name directly interpolated in f-string. Same vulnerability as BUG-001.",
      "code_snippet": "cursor.execute(f\"ALTER TABLE locations ADD COLUMN {col_name} {col_def}\")",
      "impact": "Potential SQL injection if col_name becomes user-controlled",
      "scenario": "If function is ever exposed to user input, SQL injection is possible",
      "recommendation": "Use identifier quoting or parameterized approaches"
    },
    {
      "id": "BUG-003",
      "file": "/home/user/aupat/scripts/import_media.py",
      "line": 141,
      "category": "SQL_INJECTION",
      "severity": "HIGH",
      "title": "SQL Injection via f-string with table and field names",
      "description": "Table name and field prefix directly interpolated in f-string without parameterization.",
      "code_snippet": "cursor.execute(f\"\"\"\n    INSERT INTO {table} (\n        {prefix}_uuid, loc_uuid, sub_uuid, {prefix}_sha,\n        ...\n    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n\"\"\")",
      "impact": "If table or prefix variables become user-controlled, direct SQL injection",
      "scenario": "If category value is tampered with, attackers could inject arbitrary table names",
      "recommendation": "Use a whitelist dictionary mapping and parameterized identifiers"
    },
    {
      "id": "BUG-004",
      "file": "/home/user/aupat/scripts/health_check.py",
      "line": 117,
      "category": "SQL_INJECTION",
      "severity": "MEDIUM",
      "title": "SQL Injection via f-string in test table creation",
      "description": "Test table name interpolated via f-string. While test_table is controlled, demonstrates poor practice.",
      "code_snippet": "cursor.execute(f\"CREATE TEMP TABLE {test_table} (id INTEGER)\")",
      "impact": "Sets bad precedent in codebase; if test_table ever becomes user-influenced, SQL injection",
      "scenario": "Code review finds this pattern and developers copy it to user-facing APIs",
      "recommendation": "Use identifier quoting syntax or named temporary tables"
    },
    {
      "id": "BUG-005",
      "file": "/home/user/aupat/scripts/api_routes_v012.py",
      "line": 1798,
      "category": "SQL_INJECTION",
      "severity": "MEDIUM",
      "title": "SQL Injection via f-string with field names in SELECT",
      "description": "Field names directly interpolated in SELECT statement. Although field is validated against allowed_fields list, f-string usage is vulnerable to developer mistakes.",
      "code_snippet": "cursor.execute(f\"\"\"\n    SELECT {field}, COUNT(*) as count\n    FROM locations\n    WHERE {field} IS NOT NULL\n    ...\n\"\"\")",
      "impact": "If whitelist validation is ever removed or bypassed, SQL injection occurs",
      "scenario": "Developer removes whitelist check to 'improve' performance, enabling SQL injection",
      "recommendation": "Use parameter binding for identifiers or safer identifier handling patterns"
    },
    {
      "id": "BUG-006",
      "file": "/home/user/aupat/scripts/api_v010_locations.py",
      "line": 410,
      "category": "SQL_INJECTION",
      "severity": "MEDIUM",
      "title": "SQL Injection via f-string with field names",
      "description": "Similar to BUG-005: field names in autocomplete endpoint interpolated via f-string.",
      "code_snippet": "cursor.execute(f\"\"\"\n    SELECT DISTINCT {field}\n    FROM locations\n    WHERE {field} IS NOT NULL AND {field} != ''\n    ...\n\"\"\")",
      "impact": "SQL injection if whitelist validation is bypassed",
      "scenario": "Whitelist check removed due to refactoring, enabling SQL injection attacks",
      "recommendation": "Use parameterized identifiers or remove f-strings entirely"
    },
    {
      "id": "BUG-007",
      "file": "/home/user/aupat/scripts/db_migrate_v013.py",
      "line": 64,
      "category": "SQL_INJECTION",
      "severity": "LOW",
      "title": "SQL Injection via f-string in PRAGMA statement",
      "description": "Table name interpolated in PRAGMA table_info query via f-string.",
      "code_snippet": "cursor.execute(f\"PRAGMA table_info({table_name})\")",
      "impact": "If table_name becomes user-controlled, SQL injection on schema information",
      "scenario": "Future code allows users to inspect table schemas, enabling SQL injection",
      "recommendation": "Use parameterized PRAGMA or identifier quoting"
    },
    {
      "id": "BUG-008",
      "file": "/home/user/aupat/scripts/health_check.py",
      "line": 78,
      "category": "RESOURCE_LEAK",
      "severity": "MEDIUM",
      "title": "Database connection not closed in exception path",
      "description": "In check_database_connectivity(), if an exception occurs after opening connection (line 78) but before closing (line 85), connection is leaked.",
      "code_snippet": "conn = sqlite3.connect(DB_PATH, timeout=5)\ncursor = conn.cursor()\n# if cursor.execute fails here, conn is never closed\nconn.close()",
      "impact": "Resource exhaustion after multiple failed health checks; connection pool depletion",
      "scenario": "Database locked state causes cursor.execute to raise exception, leaking connection",
      "recommendation": "Use try-finally block or context manager for connection handling"
    },
    {
      "id": "BUG-009",
      "file": "/home/user/aupat/scripts/health_check.py",
      "line": 112,
      "category": "RESOURCE_LEAK",
      "severity": "MEDIUM",
      "title": "Database connection not closed in exception path (write test)",
      "description": "Similar to BUG-008: check_database_write() doesn't guarantee connection closure.",
      "code_snippet": "conn = sqlite3.connect(DB_PATH, timeout=5)\ncursor = conn.cursor()\n# exception here leaks connection\nconn.close()",
      "impact": "Resource leak leading to connection pool exhaustion",
      "scenario": "Create table fails, connection not closed, pool depleted after repeated failures",
      "recommendation": "Use finally block or context manager"
    },
    {
      "id": "BUG-010",
      "file": "/home/user/aupat/scripts/api_v010_locations.py",
      "line": 27,
      "category": "RESOURCE_LEAK",
      "severity": "MEDIUM",
      "title": "File handle not closed when JSON parsing fails",
      "description": "In get_db_connection(), if json.load(f) throws JSONDecodeError, file handle leaks.",
      "code_snippet": "with open(config_path, 'r') as f:\n    config = json.load(f)\ndb_path = Path(config['db_loc']) / config['db_name']",
      "impact": "File descriptor leak if user.json is malformed",
      "scenario": "Corrupted user.json causes json.load() to fail, file handle leaked",
      "recommendation": "Exception handling is OK (with statement handles it), but add error validation"
    },
    {
      "id": "BUG-011",
      "file": "/home/user/aupat/scripts/api_routes_bookmarks.py",
      "line": 336,
      "category": "RESOURCE_LEAK",
      "severity": "MEDIUM",
      "title": "Database connection not closed on early return",
      "description": "In get_bookmark(), if bookmark not found (line 338), return before checking close behavior.",
      "code_snippet": "conn.close()\nif not row:\n    return jsonify({'error': 'Bookmark not found'}), 404",
      "impact": "Connection actually closed before return, but pattern is fragile - easy to break on refactoring",
      "scenario": "Developer moves close() statement below return, connection leaks",
      "recommendation": "Use try-finally or context managers consistently"
    },
    {
      "id": "BUG-012",
      "file": "/home/user/aupat/scripts/archive_worker.py",
      "line": 149,
      "category": "RESOURCE_LEAK",
      "severity": "MEDIUM",
      "title": "Database connection not properly closed in fetch_pending_urls",
      "description": "Connection closed after fetchall(), but no finally block ensures closure on exception.",
      "code_snippet": "conn = get_db_connection(db_path)\ncursor = conn.cursor()\ncursor.execute(...)\nresults = [dict(row) for row in cursor.fetchall()]\nconn.close()",
      "impact": "Connection leak if cursor.execute() fails",
      "scenario": "Database locked, cursor.execute() raises exception before close() is called",
      "recommendation": "Use try-finally or with statement"
    },
    {
      "id": "BUG-013",
      "file": "/home/user/aupat/scripts/utils.py",
      "line": 386,
      "category": "SQL_INJECTION",
      "severity": "HIGH",
      "title": "SQL Injection via f-string in check_sha256_collision",
      "description": "Field name and table name interpolated directly in f-string without parameterization.",
      "code_snippet": "cursor.execute(f\"SELECT {sha_field} FROM {table} WHERE {sha_field} = ?\", (sha256,))",
      "impact": "SQL injection if file_type parameter is tampered with",
      "scenario": "Attacker calls check_sha256_collision with malicious file_type value, enabling SQL injection",
      "recommendation": "Use dictionary mapping and parameterized identifiers"
    },
    {
      "id": "BUG-014",
      "file": "/home/user/aupat/scripts/api_routes_v012.py",
      "line": 1701,
      "category": "LOGIC_ERROR",
      "severity": "LOW",
      "title": "SQL debug logging exposes sensitive structure",
      "description": "Debug log includes raw SQL UPDATE statement with field names, exposing schema to logs.",
      "code_snippet": "logger.debug(f\"[API] Executing SQL: {sql}\")",
      "impact": "Information disclosure: schema structure visible in logs; potential for log injection attacks",
      "scenario": "Attacker monitors logs, learns database schema structure for SQL injection attacks",
      "recommendation": "Don't log raw SQL; log operation type and affected record count instead"
    },
    {
      "id": "BUG-015",
      "file": "/home/user/aupat/scripts/api_routes_bookmarks.py",
      "line": 443,
      "category": "SQL_INJECTION",
      "severity": "MEDIUM",
      "title": "SQL Injection via f-string in UPDATE statement",
      "description": "Field names from update_fields array interpolated directly in f-string.",
      "code_snippet": "query = f\"UPDATE bookmarks SET {', '.join(update_fields)} WHERE bookmark_uuid = ?\"",
      "impact": "Although update_fields is built from hardcoded allowed fields, f-string usage is risky",
      "scenario": "If update_fields ever includes user input, SQL injection occurs",
      "recommendation": "Use parameterized field name handling or validation framework"
    },
    {
      "id": "BUG-016",
      "file": "/home/user/aupat/scripts/db_migrate_v010.py",
      "line": 51,
      "category": "ERROR_HANDLING",
      "severity": "LOW",
      "title": "Missing error handling for JSON parsing",
      "description": "json.load(f) can raise JSONDecodeError but no try-except wraps it.",
      "code_snippet": "with open(config_path, 'r') as f:\n    config = json.load(f)",
      "impact": "Unhandled exception if user.json is malformed; unclear error message to user",
      "scenario": "User accidentally corrupts user.json, script crashes with unhelpful traceback",
      "recommendation": "Add try-except for json.JSONDecodeError with user-friendly error message"
    },
    {
      "id": "BUG-017",
      "file": "/home/user/aupat/scripts/archive_worker.py",
      "line": 217,
      "category": "LOGIC_ERROR",
      "severity": "MEDIUM",
      "title": "Fallback snapshot_id hides parsing failure",
      "description": "If extract_snapshot_id() returns None, code generates synthetic timestamp as fallback (line 225).",
      "code_snippet": "snapshot_id = extract_snapshot_id(result.stdout)\nif snapshot_id:\n    logger.info(f\"Archive successful, snapshot_id: {snapshot_id}\")\n    return snapshot_id\nelse:\n    logger.warning(f\"Could not extract snapshot_id from ArchiveBox output\")\n    return str(time.time())",
      "impact": "Silent failure of snapshot_id extraction masked by synthetic ID; database integrity issues",
      "scenario": "ArchiveBox output format changes, snapshot_id not extracted, fake ID stored, archive lookup fails",
      "recommendation": "Return None on extraction failure, let caller handle error; don't silently generate fake IDs"
    },
    {
      "id": "BUG-018",
      "file": "/home/user/aupat/scripts/import_media.py",
      "line": 175,
      "category": "SQL_INJECTION",
      "severity": "HIGH",
      "title": "SQL Injection via f-string in UPDATE statement",
      "description": "Table name and prefix directly interpolated in UPDATE statement.",
      "code_snippet": "cursor.execute(f\"UPDATE {table} SET verified = 1 WHERE {prefix}_uuid = ?\", (file_uuid,))",
      "impact": "SQL injection if table or prefix variables become attacker-controlled",
      "scenario": "If get_file_category() returns attacker-controlled values, SQL injection possible",
      "recommendation": "Use whitelist dictionary for table/prefix mapping"
    },
    {
      "id": "BUG-019",
      "file": "/home/user/aupat/scripts/api_v010_map.py",
      "line": 79,
      "category": "UNKNOWN",
      "severity": "MEDIUM",
      "title": "Potential SQL Injection - requires code review",
      "description": "File uses f-string SQL construction pattern; specific line not fully reviewed",
      "code_snippet": "cursor.execute(f\"\"\"...\"\"\") detected at line 79",
      "impact": "Likely SQL injection vulnerability similar to other files",
      "scenario": "Malformed query due to f-string interpolation",
      "recommendation": "Replace f-strings with parameterized queries throughout"
    },
    {
      "id": "BUG-020",
      "file": "/home/user/aupat/scripts/api_v010_notes.py",
      "line": 164,
      "category": "UNKNOWN",
      "severity": "MEDIUM",
      "title": "Potential SQL Injection - f-string detected",
      "description": "Similar pattern to other files; f-string SQL construction",
      "code_snippet": "cursor.execute(f\"\"\"...\"\"\") detected at line 164",
      "impact": "Potential SQL injection",
      "scenario": "User-controlled input in query construction",
      "recommendation": "Use parameterized queries"
    },
    {
      "id": "BUG-021",
      "file": "/home/user/aupat/scripts/api_routes_v012.py",
      "line": 31,
      "category": "SECURITY",
      "severity": "HIGH",
      "title": "CORS configuration allows all origins",
      "description": "Access-Control-Allow-Origin set to '*' allowing any website to access API",
      "code_snippet": "response.headers.add('Access-Control-Allow-Origin', '*')",
      "impact": "CSRF attacks possible; any website can access API on behalf of users; sensitive data exposure",
      "scenario": "Malicious website makes requests to AUPAT API using victim's credentials/session",
      "recommendation": "Set specific allowed origins in environment config, default to localhost for dev"
    },
    {
      "id": "BUG-022",
      "file": "/home/user/aupat/scripts/normalize.py",
      "line": 141,
      "category": "ERROR_HANDLING",
      "severity": "LOW",
      "title": "Broad exception handling hides actual errors",
      "description": "Catches all exceptions from libpostal parsing, silently falls back to simple normalization",
      "code_snippet": "except Exception as e:\n    logger.warning(f\"libpostal parsing failed for '{name}': {e}, using fallback\")",
      "impact": "Real errors (OutOfMemory, etc.) silently ignored; difficult to debug issues",
      "scenario": "Memory error in libpostal silently ignored, function continues with partial results",
      "recommendation": "Catch specific exceptions; re-raise unexpected ones"
    },
    {
      "id": "BUG-023",
      "file": "/home/user/aupat/scripts/db_verify.py",
      "line": 59,
      "category": "RESOURCE_LEAK",
      "severity": "MEDIUM",
      "title": "Database connection not guaranteed to close on exception",
      "description": "Connection opened at line 59 but only closed inside try block; exceptions before close() leak connection.",
      "code_snippet": "conn = sqlite3.connect(db_path)\ncursor = conn.cursor()\ntry:\n    # operations\nfinally:\n    # close is inside try block, but exceptions in try that occur before close still leak",
      "impact": "Connection leak if exception occurs during cursor operations",
      "scenario": "Database corruption causes cursor.execute() to fail, connection not closed",
      "recommendation": "Move conn.close() to finally block outside the try"
    },
    {
      "id": "BUG-024",
      "file": "/home/user/aupat/scripts/immich_integration.py",
      "line": 118,
      "category": "ERROR_HANDLING",
      "severity": "MEDIUM",
      "title": "Silent failure in GPS extraction from JSON",
      "description": "json.loads() can fail but exception is caught broadly; GPS extraction failure silently ignored",
      "code_snippet": "data = json.loads(result.stdout)\nif not data:\n    return None\n# if data[0] throws IndexError, not caught",
      "impact": "Malformed GPS data silently returns None instead of logging error",
      "scenario": "Exiftool output format changes, GPS extraction fails silently, locations lack coordinates",
      "recommendation": "Add explicit error handling for JSON parsing and data access"
    },
    {
      "id": "BUG-025",
      "file": "/home/user/aupat/scripts/api_routes_v012.py",
      "line": 1701,
      "category": "SECURITY",
      "severity": "MEDIUM",
      "title": "Verbose error messages expose database schema",
      "description": "Exception messages logged and potentially returned to client expose database structure",
      "code_snippet": "logger.error(f\"[API] Failed to update location {loc_uuid}: {str(e)}\")",
      "impact": "Information disclosure: database schema revealed to attackers through error messages",
      "scenario": "Attacker intentionally sends invalid requests, reads error responses to learn schema",
      "recommendation": "Log full details internally, return generic error message to clients"
    },
    {
      "id": "BUG-026",
      "file": "/home/user/aupat/scripts/db_organize.py",
      "line": 45,
      "category": "ERROR_HANDLING",
      "severity": "LOW",
      "title": "Missing error handling for JSON file load",
      "description": "json.load(f) can raise JSONDecodeError without explicit error handling",
      "code_snippet": "with open(hardware_path, 'r') as f:\n    return json.load(f)",
      "impact": "Unhandled exception if camera_hardware.json is malformed",
      "scenario": "User corrupts camera_hardware.json, script crashes with unhelpful error",
      "recommendation": "Add try-except for JSONDecodeError with fallback to empty dict"
    },
    {
      "id": "BUG-027",
      "file": "/home/user/aupat/scripts/api_routes_bookmarks.py",
      "line": 288,
      "category": "ERROR_HANDLING",
      "severity": "LOW",
      "title": "JSON parsing error silently creates empty list",
      "description": "JSONDecodeError caught but silently converts to empty array, hiding malformed data",
      "code_snippet": "try:\n    bookmark['tags'] = json.loads(bookmark['tags'])\nexcept json.JSONDecodeError:\n    bookmark['tags'] = []",
      "impact": "Silently loses tags data; user data loss without warning",
      "scenario": "Corrupted tags JSON stored in DB, silently discarded on retrieval",
      "recommendation": "Log warning and optionally flag record as having corrupted data"
    },
    {
      "id": "BUG-028",
      "file": "/home/user/aupat/scripts/api_routes_v012.py",
      "line": 1701,
      "category": "LOGIC_ERROR",
      "severity": "LOW",
      "title": "Redundant error logging",
      "description": "Error logged multiple times with different levels and formats (lines 1725-1729)",
      "code_snippet": "logger.error(f\"[API] Failed to update location...: {str(e)}\")\nlogger.error(f\"[API] Error type: {type(e).__name__}\")\nlogger.error(f\"[API] Error details: {repr(e)}\")\nlogger.error(f\"[API] Traceback: {traceback.format_exc()}\")",
      "impact": "Log bloat; difficult to monitor logs; may hide real issues",
      "scenario": "Production logs filled with excessive error details, signal to noise ratio poor",
      "recommendation": "Log once with traceback; avoid redundant error context logging"
    },
    {
      "id": "BUG-029",
      "file": "/home/user/aupat/scripts/utils.py",
      "line": 95,
      "category": "SQL_INJECTION",
      "severity": "HIGH",
      "title": "SQL Injection via f-string in generate_uuid",
      "description": "Table name and field name interpolated directly in f-string.",
      "code_snippet": "query = f\"SELECT {uuid_field} FROM {table_name} WHERE SUBSTR({uuid_field}, 1, 8) = ?\"",
      "impact": "SQL injection if table_name or uuid_field become user-controlled",
      "scenario": "If function is exposed through API, attackers can inject arbitrary SQL",
      "recommendation": "Use parameter validation and identifier quoting"
    },
    {
      "id": "BUG-030",
      "file": "/home/user/aupat/scripts/api_v010_locations.py",
      "line": 304,
      "category": "SQL_INJECTION",
      "severity": "MEDIUM",
      "title": "SQL Injection via f-string in UPDATE with dynamic fields",
      "description": "Field names from allowed_fields list interpolated via f-string in UPDATE statement.",
      "code_snippet": "cursor.execute(f\"\"\"\n    UPDATE locations\n    SET {', '.join(updates)}\n    WHERE loc_uuid = ?\n\"\"\")",
      "impact": "Although updates is constructed from validated field list, pattern is dangerous if validation removed",
      "scenario": "Developer removes validation, user input reaches update field names",
      "recommendation": "Use parameterized field name handling"
    }
  ],
  "summary": {
    "total_bugs_found": 30,
    "critical": 0,
    "high": 9,
    "medium": 16,
    "low": 5,
    "by_category": {
      "SQL_INJECTION": 11,
      "RESOURCE_LEAK": 6,
      "ERROR_HANDLING": 5,
      "SECURITY": 3,
      "LOGIC_ERROR": 3,
      "UNKNOWN": 2
    },
    "most_critical_issues": [
      "Multiple SQL injection vulnerabilities via f-string interpolation of table and field names",
      "Broad CORS configuration allowing access from any origin",
      "Database connections not guaranteed to close on exceptions",
      "Verbose error messages exposing database schema to clients",
      "Fallback synthetic values hiding actual errors in archive worker"
    ],
    "recommendations": [
      "Replace all f-string SQL construction with parameterized queries",
      "Audit and tighten CORS configuration to specific allowed origins",
      "Implement consistent try-finally or context manager usage for database connections",
      "Add generic error responses for clients while logging detailed errors server-side",
      "Add explicit error handling instead of silent failures with fallback values",
      "Implement input validation framework for API parameters",
      "Add logging for security-relevant events without exposing sensitive information"
    ]
  }
}
