# AUPAT Development Methodology

## Purpose

This document defines the bulletproof workflow for all code development, troubleshooting, planning, and brainstorming in the AUPAT project. Follow these steps religiously to maintain code quality, reliability, and long-term maintainability.

---

## Core Principles (In Order of Importance)

### 1. BPA - Best Practices Always
- Never compromise on industry best practices
- Code must follow established patterns and standards
- Security, performance, and maintainability come first
- Research best practices before implementing anything new
- When in doubt, choose the battle-tested approach
- No shortcuts that create technical debt

### 2. BPL - Bulletproof Longterm
- Code must survive years of use without modification
- Anticipate future edge cases and failure modes
- Build defensive systems that fail gracefully
- Prioritize data integrity above all else
- No technical debt - do it right the first time
- Think in terms of decades, not months

### 3. KISS - Keep It Simple Stupid
- Simplicity trumps cleverness every time
- If it requires extensive comments to understand, it's too complex
- Prefer readable code over performant code (unless performance is critical)
- One function, one purpose - no exceptions
- Avoid over-engineering and premature optimization
- Simple solutions are easier to maintain and debug

### 4. FAANG PE - FAANG-Level Engineering (Personal Edition)
- Production-grade code quality without enterprise bloat
- Scalable architecture appropriate for small business needs
- Proper error handling, logging, and monitoring
- Code review standards (self-review thoroughly)
- Think like a senior engineer at a top tech company, but stay pragmatic
- High standards without unnecessary complexity

### 5. WWYDD - What Would You Do Differently Logic
- Only invoke when there's an urgent, major, or fatal flaw
- Challenge the plan when something feels fundamentally wrong
- Ask: "If I had to rebuild this in 5 years, what would I regret?"
- Don't be afraid to scrap and restart if the foundation is broken
- Trust your instincts when code smells bad
- Better to restart now than fix a broken foundation later

### 6. NEE - NO EMOJIS EVER
- Professional documentation only
- Emojis are distracting and unprofessional
- Use clear, concise language instead
- Markdown formatting for emphasis (bold, italic, code blocks)
- Code is serious business, treat it seriously

### 7. No Self-Credit
- Don't credit tooling in code comments or documentation
- Code speaks for itself
- Focus on what the code does, not who/what wrote it
- Attribution is tacky and adds noise
- No "Generated by..." or "Written with..." comments

---

## When-Applicable Rules

### Transaction Safety (Database Operations)
- Wrap all database modifications in BEGIN/COMMIT/ROLLBACK
- Define clear transaction boundaries
- Implement rollback procedures for every operation
- Test rollback scenarios explicitly
- Never leave database in inconsistent state
- Log transaction start/commit/rollback for debugging

### PRAGMA foreign_keys = ON (SQLite)
- Always enable foreign key constraints at connection time
- Verify cascade behavior is correct (DELETE, UPDATE)
- Test foreign key violations explicitly
- Document all relationships clearly
- Never disable foreign keys to "make something work"

### Error Handling (All Code)
- Try/except blocks for every external call (file I/O, database, network)
- Specific exception types, never bare except
- Log errors with full context (what failed, why, what was attempted, input values)
- Graceful degradation when possible
- Fail fast when data integrity is at risk
- Include exception chaining for debugging

### Input Validation (All User Input)
- Never trust user input - validate everything
- Validate types, ranges, formats, lengths
- Sanitize for SQL injection, path traversal, XSS
- Fail early with clear, actionable error messages
- Document validation rules in code and documentation
- Test with malicious input during development

---

## The 9-Step Bulletproof Workflow

This is the mandatory workflow for ALL development tasks: bug fixes, new features, refactoring, troubleshooting, planning, and brainstorming. No exceptions.

### Step 1: Audit the Code
**Purpose**: Verify current state against documentation and identify gaps

**Tasks**:
- Read all relevant .py script files completely (don't skim)
- Read all related .md documentation files
- Read all .json configuration files
- Read implementation guides and best practices documentation
- Compare code against documentation (are they in sync?)
- Identify what's complete vs incomplete vs missing
- List all dependencies and verify they exist
- Check for obvious bugs, security issues, or logic flaws
- Verify file paths, imports, and function names are correct

**Output**:
- Audit report listing:
  - Files reviewed (with paths)
  - Current implementation status (% complete)
  - Gaps between documentation and code
  - Identified issues categorized by severity (critical/major/minor)
  - Missing components
  - Dependencies status

**Common Mistakes to Avoid**:
- Skimming files instead of reading thoroughly
- Assuming documentation is accurate without verification
- Missing implicit dependencies
- Not checking for security issues

---

### Step 2: Draft the Plan
**Purpose**: Create clear, actionable plan to fix/implement

**Tasks**:
- Define the goal clearly (what are we trying to accomplish and why?)
- List all files that need to be created, modified, or deleted
- Outline the specific changes needed in each file
- Define success criteria (how do we know it works?)
- Identify risks and mitigation strategies
- Estimate complexity (simple/moderate/complex)
- Sequence operations in logical order (dependencies matter)
- Identify testing approach

**Output**:
- Written plan with:
  - Objective statement (one clear sentence)
  - File-by-file change list with specifics
  - Sequencing and dependencies clearly marked
  - Success criteria (measurable)
  - Risk assessment with mitigations
  - Testing strategy

**Common Mistakes to Avoid**:
- Vague objectives ("make it better")
- Missing file dependencies
- No success criteria
- Ignoring risks

---

### Step 3: Audit the Plan (First Pass)
**Purpose**: Ensure plan follows all core principles and best practices

**Tasks**:
- Check against BPA: Does it follow best practices?
  - Are we using proven patterns?
  - Are libraries/approaches well-established?
  - Does it follow language idioms?
- Check against BPL: Will this work in 5 years?
  - Will dependencies still exist?
  - Is the approach future-proof?
  - Will it handle growth?
- Check against KISS: Is it as simple as possible?
  - Can we simplify further?
  - Are we over-engineering?
  - Is complexity justified?
- Check against FAANG PE: Is it production-grade?
  - Proper error handling?
  - Logging and monitoring?
  - Performance acceptable?
- Check against WWYDD: Any fatal flaws?
  - Is the foundation solid?
  - Would we regret this approach?
  - Any design smells?
- Check Python best practices (PEP 8, typing, docstrings)
- Check database best practices (indexes, transactions, normalization)
- Check security best practices (input validation, SQL injection, etc.)
- Verify transaction safety for database operations
- Verify error handling for all failure modes

**Output**:
- Updated plan incorporating all feedback
- List of principle violations fixed
- Rationale for any deviations from principles (should be rare)
- Confirmation plan meets all standards

**Common Mistakes to Avoid**:
- Rubber-stamping the plan without critical review
- Ignoring principle violations
- Accepting complexity without justification
- Skipping security review

---

### Step 4: Deep Review and Re-Audit
**Purpose**: Catch errors before implementation through exhaustive review

**Tasks**:
- Re-read ALL related files (.py, .md, .json, .pdf) again from scratch
- Verify plan matches current reality (no stale assumptions)
- Check for consistency across all documentation
- Look for edge cases not covered in plan
- Verify dependencies are correctly identified
- Confirm file paths, variable names, function names are accurate
- Double-check SQL queries for correctness
- Review error handling paths for completeness
- Verify data flow from input to output
- Check for race conditions or concurrency issues

**Output**:
- Final audited plan with corrections
- Confirmation that plan is accurate and complete
- List of edge cases to test
- Updated risk assessment if new issues found

**Common Mistakes to Avoid**:
- Assuming plan is correct from Step 3
- Not re-reading files (relying on memory)
- Missing edge cases
- Ignoring newly discovered risks

---

### Step 5: Write Implementation Guide
**Purpose**: Create clear instructions aimed at less-experienced coder

**Tasks**:
- Write step-by-step guide someone junior could follow
- Explain WHY each change is needed, not just WHAT
- Include code examples with detailed explanations
- Document core logic and algorithms with plain English descriptions
- Explain tricky parts in detail (don't assume knowledge)
- Include links to relevant documentation (Python docs, SQLite docs, etc.)
- Add warnings for common pitfalls
- Describe expected behavior at each step
- Include visual aids (diagrams, flowcharts) if helpful
- Specify exact commands to run and expected output

**Output**:
- Implementation guide with:
  - Prerequisites and setup instructions
  - Step-by-step instructions (numbered, sequential)
  - Code snippets with line-by-line explanations
  - Expected outcomes at each step
  - Common errors and how to fix them
  - Troubleshooting tips
  - Testing instructions

**Common Mistakes to Avoid**:
- Assuming too much knowledge
- Explaining WHAT without WHY
- Missing setup steps
- No troubleshooting section

---

### Step 6: Audit Implementation Guide
**Purpose**: Ensure guide is clear, complete, and correct

**Tasks**:
- Read guide from perspective of junior developer (pretend you know nothing)
- Verify all steps are clear and unambiguous
- Check that core logic is explained thoroughly
- Ensure code examples are correct, complete, and runnable
- Confirm troubleshooting section covers likely issues
- Fix any confusing language or gaps
- Add diagrams, examples, or clarifications where needed
- Verify prerequisites are complete
- Test that steps are in correct order

**Output**:
- Refined implementation guide
- Confirmation guide is comprehensive and clear
- List of improvements made

**Common Mistakes to Avoid**:
- Reading as an expert (not a beginner)
- Skipping code example verification
- Incomplete troubleshooting section
- Assuming steps are obvious

---

### Step 7: Refine Guide with Core Logic Explanations
**Purpose**: Ensure deep understanding through clear logic explanations

**Tasks**:
- Review each algorithm and complex section
- Add plain English explanations of the core logic
- Explain the "how" and "why" behind complex operations
- Add examples of data transformation at each step
- Document assumptions and invariants
- Explain non-obvious design decisions
- Add references to relevant patterns or algorithms
- Include complexity analysis if relevant (O(n), etc.)
- Ensure explanations are accurate and precise

**Output**:
- Final implementation guide with comprehensive logic explanations
- Confirmation that a junior developer could implement from guide
- Documentation of all core algorithms and logic

**Common Mistakes to Avoid**:
- Using jargon without explanation
- Skipping "obvious" parts that aren't obvious
- Incomplete data flow explanations
- Missing design rationale

---

### Step 8: Write or Update the Code
**Purpose**: Implement the planned changes following the guide

**Tasks**:
- Follow implementation guide exactly (it's your blueprint)
- Write clean, readable code (optimize for maintainability)
- Add docstrings for all functions, classes, and modules (Google style)
- Add inline comments for complex logic only (code should be self-documenting)
- Follow naming conventions consistently (PEP 8 for Python)
- Implement error handling for all external calls
- Add logging at appropriate levels (DEBUG, INFO, WARNING, ERROR)
- Include input validation for all user inputs
- Implement transaction safety where applicable
- Keep functions small and focused (one purpose per function)
- Use type hints for all function parameters and returns
- Write defensive code (check assumptions, validate state)

**Output**:
- Updated .py files with complete implementation
- Updated .md documentation if specifications changed
- Updated .json configuration if schema changed
- Code that passes linting and type checking

**Common Mistakes to Avoid**:
- Deviating from the implementation guide
- Missing error handling
- Inadequate logging
- Magic numbers (use named constants)
- Functions doing multiple things
- Missing type hints or docstrings

---

### Step 9: Test End-to-End
**Purpose**: Verify code works as intended in all scenarios

**Tasks**:
- Test happy path (everything works perfectly)
- Test error paths (files missing, bad input, network failure, etc.)
- Test edge cases identified in audits
- Test boundary conditions (empty input, max values, etc.)
- Test rollback and recovery procedures
- Verify logging output is useful and actionable
- Check database state before and after operations
- Test with small dataset first, then progressively larger
- Verify no data corruption or loss
- Test idempotency (can it run twice safely without side effects?)
- Performance check (is it reasonably fast? any bottlenecks?)
- Test concurrent operations if applicable
- Test with malicious input (SQL injection, path traversal, etc.)

**Output**:
- Test results document with:
  - What was tested (specific test cases)
  - Expected vs actual results (pass/fail)
  - Any issues found and how they were fixed
  - Performance metrics (execution time, memory usage)
  - Confirmation all tests pass
  - Edge cases verified
  - Security tests passed

**Common Mistakes to Avoid**:
- Only testing happy path
- Not testing with real data
- Skipping error cases
- Not verifying data integrity
- Ignoring performance
- Not testing rollback procedures

---

## Troubleshooting Workflow

When code isn't working as expected:

1. **Read error messages completely and carefully**
   - Don't skim - every word matters
   - Note the exact error type and line number

2. **Verify input data is valid and expected format**
   - Print/log the actual input received
   - Check data types, values, formats

3. **Check logs for detailed error context**
   - Look for warnings before the error
   - Check timestamps and sequence of events

4. **Isolate the failing component**
   - Which function/step fails?
   - Binary search the problem (comment out sections)

5. **Test that component in isolation**
   - Create minimal test case
   - Remove all other variables

6. **Verify assumptions**
   - Does file exist? Check with ls/os.path.exists
   - Is database writable? Check permissions
   - Are dependencies installed? Check imports

7. **Check recent changes**
   - What changed since it last worked?
   - Use git diff to review changes

8. **Add more logging if needed**
   - Log variable values at each step
   - Log function entry/exit
   - Log decision points (if/else branches)

9. **Fix root cause, not symptoms**
   - Don't add try/except to hide errors
   - Understand why it failed
   - Fix the underlying problem

10. **Test fix thoroughly before moving on**
    - Verify fix works in all scenarios
    - Ensure fix doesn't break other things
    - Add test to prevent regression

11. **Document the issue and solution**
    - Add comment explaining the fix
    - Update documentation if needed
    - Add to troubleshooting guide

---

## Planning Workflow

When planning new features or major changes:

1. **Define the problem clearly**
   - What are we solving?
   - Why is it a problem?
   - Who is affected?

2. **Research existing solutions and best practices**
   - How do others solve this?
   - What are industry standards?
   - What libraries/tools exist?

3. **Draft multiple approaches (at least 2-3 options)**
   - Brainstorm different ways to solve it
   - Consider tradeoffs of each

4. **Evaluate each against core principles**
   - Score each on BPA, BPL, KISS, FAANG PE
   - Identify risks and benefits
   - Consider long-term implications

5. **Choose best approach**
   - Simplest that meets all principles
   - Document why other approaches rejected
   - Get feedback if high-risk decision

6. **Follow full 9-step workflow for implementation**
   - No shortcuts for "simple" features
   - Every feature deserves the full process

---

## Brainstorming Workflow

When exploring ideas or solving novel problems:

1. **State the goal/challenge clearly**
   - Write it down in one sentence
   - Define success criteria

2. **Generate ideas without filtering**
   - Quantity over quality at this stage
   - No idea is too crazy
   - Encourage creativity

3. **After exhausting ideas, apply principle filters**
   - Which ideas follow BPA?
   - Which ideas are BPL?
   - Which ideas are KISS?
   - Which ideas meet FAANG PE standards?
   - Eliminate ideas that violate core principles

4. **Narrow to top 2-3 ideas**
   - Based on principles and feasibility
   - Consider resource constraints
   - Evaluate risks

5. **Prototype or deeply analyze finalists**
   - Build quick proof of concept
   - Or do detailed technical analysis
   - Test assumptions

6. **Choose winner based on principles + feasibility**
   - Document decision rationale
   - Explain tradeoffs accepted

7. **Proceed with planning workflow**
   - Treat chosen idea as new feature
   - Follow full process

---

## Code Review Checklist

Before committing any code, verify ALL of these:

### Core Principles
- [ ] Code follows BPA (best practices verified)
- [ ] Code follows BPL (will last years)
- [ ] Code follows KISS (simplest possible solution)
- [ ] Code follows FAANG PE (production-grade quality)
- [ ] No emojis anywhere in code or comments
- [ ] No self-credit or tool attribution

### Code Quality
- [ ] All functions have docstrings (Google style)
- [ ] All functions have type hints (parameters and return)
- [ ] Naming follows conventions (PEP 8 for Python)
- [ ] Code is readable without excessive comments
- [ ] Functions are small and focused (one purpose)
- [ ] No magic numbers (use named constants)
- [ ] No dead code or commented-out code
- [ ] No unused imports or variables
- [ ] Indentation and formatting consistent

### Error Handling & Robustness
- [ ] Error handling for all external calls (file I/O, database, network)
- [ ] Specific exception types (not bare except)
- [ ] Input validation for all user input
- [ ] Edge cases handled (empty input, None, max values)
- [ ] Graceful degradation where appropriate
- [ ] Fail fast when data integrity at risk

### Database Operations
- [ ] Transaction safety for all modifications
- [ ] PRAGMA foreign_keys = ON in connection
- [ ] SQL queries tested and correct
- [ ] Indexes on frequently queried columns
- [ ] No SQL injection vulnerabilities
- [ ] Rollback procedures implemented
- [ ] Database state verified after operations

### Logging & Monitoring
- [ ] Logging at appropriate levels (DEBUG/INFO/WARNING/ERROR)
- [ ] Log messages are clear and actionable
- [ ] Sensitive data not logged
- [ ] Errors logged with full context
- [ ] Transaction boundaries logged

### Testing
- [ ] Tests written and passing
- [ ] Happy path tested
- [ ] Error paths tested
- [ ] Edge cases tested
- [ ] Performance acceptable
- [ ] Security tested (malicious input)

### Documentation
- [ ] Documentation updated to match code
- [ ] README updated if public API changed
- [ ] Inline comments for complex logic only
- [ ] No TODO comments left (finish or file issue)
- [ ] Changelog updated if applicable

---

## Documentation Standards

### All .md Files Should

- Use clear, concise language (no fluff)
- Avoid marketing speak or hype
- Focus on facts and implementation details
- Include examples where helpful
- Follow consistent formatting
- Link to related documentation
- Specify versions and dependencies where applicable
- Be accurate and up-to-date with code
- Use proper markdown syntax
- Include table of contents for long documents

### All .py Files Should

- Include module-level docstring describing purpose
- Include function/class docstrings (Google style preferred)
  ```python
  def function(param1: str, param2: int) -> bool:
      """Brief description of function.

      Longer description if needed.

      Args:
          param1: Description of param1
          param2: Description of param2

      Returns:
          Description of return value

      Raises:
          ValueError: Description of when this is raised
      """
  ```
- Use type hints for all function parameters and returns
- Follow PEP 8 style guide strictly
- Use meaningful variable and function names (no abbreviations unless standard)
- Keep line length under 100 characters
- Avoid magic numbers (use named constants at module level)
- Use constants for strings that appear multiple times

### All .json Files Should

- Use consistent indentation (4 spaces for AUPAT)
- Include version field where applicable
- Validate against schema if one exists
- Document structure in corresponding .md file
- Use meaningful key names
- Follow consistent naming convention (snake_case for AUPAT)
- Include comments in documentation, not in JSON

---

## Emergency Override (WWYDD Invocation)

If you discover a critical flaw (data loss risk, security vulnerability, fundamental design error):

1. **STOP immediately** - don't proceed with current plan
2. **Invoke WWYDD** - this is a major/fatal flaw
3. **Document the flaw clearly**
   - What is wrong?
   - Why is it critical?
   - What is the impact?
4. **Assess impact**
   - How bad is it?
   - What's affected?
   - Can it be patched or must it be redesigned?
5. **Draft emergency fix plan**
   - Immediate mitigation (stop the bleeding)
   - Long-term fix (address root cause)
   - Validation approach
6. **Get approval before proceeding** (if working with team/client)
7. **Fix with extreme care**
   - Follow 9-step workflow even in emergency
   - Don't rush and make it worse
   - Test exhaustively
8. **Test exhaustively**
   - Verify fix works
   - Verify no new issues introduced
   - Test rollback if needed
9. **Document in post-mortem**
   - What went wrong?
   - Why did it happen?
   - How did we fix it?
   - How do we prevent it in the future?

**Remember**: Data integrity always trumps deadlines. Always.

---

## Principle Conflict Resolution

When principles appear to conflict:

1. **BPA overrides all** - best practices are non-negotiable
   - If BPA says "do X" and another principle says "don't do X", do X
   - Best practices exist for good reasons

2. **BPL overrides KISS** when long-term reliability is at stake
   - Better to be slightly more complex than to fail in production
   - But challenge whether complexity is truly necessary

3. **KISS overrides FAANG PE** when simplicity prevents bugs
   - Simple code has fewer bugs than complex code
   - Production-grade doesn't mean complex

4. **WWYDD can override anything** if flaw is critical
   - Fatal flaws must be addressed
   - Trust your engineering instincts

5. **When truly stuck**, choose the option that protects data integrity
   - Data loss is unrecoverable
   - Everything else can be fixed

---

## Success Metrics

Good code following this methodology will demonstrate:

- **Zero data loss or corruption incidents** - absolute requirement
- **Clear, understandable implementation** - junior developer can read it
- **Comprehensive error handling** - no uncaught exceptions in production
- **Thorough logging for debugging** - can diagnose issues from logs alone
- **High test coverage** - all paths tested
- **Accurate documentation** - docs match code exactly
- **Easy maintenance and modification** - changes are straightforward
- **Graceful failure modes** - fails safely when it fails
- **Predictable behavior** - no surprises
- **Long-term stability** - runs for months/years without issues

---

## Version History

Track major methodology changes here:

- v1.0 - Initial methodology document
- v2.0 - Refined 9-step workflow with detailed breakdowns, expanded troubleshooting, added emergency override procedures

---

## References

### Internal Documentation
- claude.md - AI collaboration guide
- project-overview.md - Complete technical reference
- All .md files in logseq/pages/ - Detailed component specifications
- All .json schema files - Database and configuration schemas

### External References
- **Python**:
  - PEP 8 - Style Guide for Python Code
  - Python typing module documentation
  - Google Python Style Guide (for docstrings)

- **Database**:
  - SQLite Best Practices
  - SQLite JSON1 Extension Documentation
  - Database Normalization Principles

- **Security**:
  - OWASP Top 10
  - SQL Injection Prevention
  - Input Validation Best Practices

- **General**:
  - Clean Code by Robert C. Martin
  - The Pragmatic Programmer by Hunt & Thomas

---

**Remember**: This methodology exists to build bulletproof systems. Every step has a purpose. Shortcuts create technical debt. Follow the process religiously, and the code will be production-ready, maintainable, and reliable for years.
